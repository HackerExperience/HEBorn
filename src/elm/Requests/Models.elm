module Requests.Models
    exposing
        ( Model
        , initialModel
        , RequestID
        , Request(..)
        , RequestStore
        , RequestStoreData
        , RequestPayload
        , RequestPayloadArgs(..)
        , RequestDriver(..)
        , RequestTopic(..)
        , NewRequestData
        , Response(..)
        , ResponseCode(..)
        , ResponseDecoder
        , getResponseCode
        , invalidRequestId
        , noopDecoder
        , createRequestData
        , encodeData
        , storeRequest
        , getTopicDriver
          -- Custom requests
        , ResponseForUsernameExists(..)
        , ResponseUsernameExistsPayload
        , ResponseForSignUp(..)
        , ResponseSignUpPayload
        , ResponseForLogin(..)
        , ResponseLoginPayload
        , ResponseForLogout(..)
        )

import Dict
import Json.Encode
import Uuid
import Random.Pcg exposing (Seed, initialSeed, step)
import Core.Components exposing (Component(ComponentInvalid))


type alias Model =
    { requests : RequestStore
    , seed : Seed
    , uuid : String
    }


type Request
    = RequestUsername
    | RequestEmailVerification
    | RequestSignUp
    | RequestLogin
    | RequestLogout
    | RequestInvalid
    | NewRequest NewRequestData


type alias RequestID =
    String



{- RequestStore is a dict with information about all requests we are waiting for
   responses. This dict is identified by the request id (an UUID generated by the
   client, sent as `request_id` on payload and received as `request_id` once the
   server replies us). It is stored on the main App Model.
-}


type alias RequestStoreData =
    ( Component, Request, ResponseDecoder )


type alias RequestStore =
    Dict.Dict RequestID RequestStoreData



{- NewRequestData is a 3-tuple used internally when creating new requests. It
   contains all required information to queue and submit a new request to the
   server. This type alias is used to simplify the representation of the 3-tuple.
-}


type alias NewRequestData =
    ( Request, RequestTopic, RequestPayload, ResponseDecoder )



{- RequestPayload represents the payload we send to the server. It is identical
   for every request, except for the `args` key. The `args` is unique for each
   Request.
-}


type alias RequestPayload =
    { topic : RequestTopic
    , args : RequestPayloadArgs
    , request_id : RequestID
    }



{- RequestPayloadArgs is a list of Request payloads along with their expected
   args. The actual definition of expected payload args is implemented below for
   each request
-}


type RequestPayloadArgs
    = RequestUsernamePayload RequestUsernameArgs
    | RequestEmailVerificationPayload RequestEmailVerificationArgs
    | RequestSignUpPayload RequestSignUpArgs
    | RequestLoginPayload RequestLoginArgs
    | RequestLogoutPayload RequestLogoutArgs



{- Expected payload for each Request's args -}


type alias RequestUsernameArgs =
    { user : String }


type alias RequestEmailVerificationArgs =
    { email : String }


type alias RequestSignUpArgs =
    { email : String, password : String, username : String }


type alias RequestLoginArgs =
    { username : String, password : String }


type alias RequestLogoutArgs =
    { token : String }



-- Responses


type Response
    = ResponseUsernameExists ResponseForUsernameExists
    | ResponseSignUp ResponseForSignUp
    | ResponseLogin ResponseForLogin
    | ResponseLogout ResponseForLogout
    | ResponseEmpty
    | ResponseInvalid



{- ResponseDecoder is used internally and it's an alias to represent the result
   of decoders implemented on each component's requests module. Regardless of the
   input (which is the key `data` received on a WSResponse) we must always return
   a Response, which then will be handled by the component.
-}


type alias ResponseDecoder =
    RequestID -> ResponseCode -> Response



{- Expected content on the `data` field of the response received by the server.
   It is analogous to `RequestPayloadArgs`
-}
-- type ResponseData
--     = ResponseDataUsernameExists ResponseForUsernameExists
--     | ResponseDataSignUp ResponseForSignUp
--     | EmptyResponse


type ResponseCode
    = ResponseCodeOk
    | ResponseCodeNotFound
    | ResponseCodeUnknownError



{- Definition of each Response's expected fields and/or state -}


type ResponseForUsernameExists
    = ResponseUsernameExistsOk ResponseUsernameExistsPayload
    | ResponseUsernameExistsInvalid


type alias ResponseUsernameExistsPayload =
    { user : String }


type ResponseForSignUp
    = ResponseSignUpOk ResponseSignUpPayload
    | ResponseSignUpInvalid


type alias ResponseSignUpPayload =
    { username : String
    , email : String
    , account_id : String
    }


type ResponseForLogin
    = ResponseLoginOk ResponseLoginPayload
    | ResponseLoginFailed
    | ResponseLoginInvalid


type alias ResponseLoginPayload =
    { token : String }


type ResponseForLogout
    = ResponseLogoutOk
    | ResponseLogoutInvalid


{-| encodeData is the specific encoding part of the parent encodeRequest. Since
the content of `args` varies for each request, we must tell Elm how to encode
each RequestPayloadArgs.
-}
encodeData : RequestPayloadArgs -> Json.Encode.Value
encodeData args =
    case args of
        RequestUsernamePayload args ->
            Json.Encode.object
                [ ( "user", Json.Encode.string args.user ) ]

        RequestEmailVerificationPayload args ->
            Json.Encode.object
                [ ( "email", Json.Encode.string args.email ) ]

        RequestSignUpPayload args ->
            Json.Encode.object
                [ ( "email", Json.Encode.string args.email )
                , ( "username", Json.Encode.string args.username )
                , ( "password", Json.Encode.string args.password )
                ]

        RequestLoginPayload args ->
            Json.Encode.object
                [ ( "username", Json.Encode.string args.username )
                , ( "password", Json.Encode.string args.password )
                ]

        RequestLogoutPayload args ->
            Json.Encode.object
                [ ( "token", Json.Encode.string args.token ) ]


type RequestDriver
    = DriverWebsocket
    | DriverHTTP


type RequestTopic
    = TopicAccountLogin
    | TopicAccountCreate


getTopicDriver : RequestTopic -> RequestDriver
getTopicDriver topic =
    case topic of
        TopicAccountCreate ->
            DriverHTTP

        TopicAccountLogin ->
            DriverHTTP


{-| Aggregates the required data to create a request into a 3-tuple defined by RequestData
-}
createRequestData :
    Request
    -> ResponseDecoder
    -> RequestTopic
    -> RequestPayloadArgs
    -> NewRequestData
createRequestData request decoder topic args =
    ( request
    , topic
    , { topic = topic
      , args = args
      , request_id = ""
      }
    , decoder
    )



-- Initial data


noopDecoder : ResponseDecoder
noopDecoder msg code =
    ResponseInvalid


initialRequest : RequestStore
initialRequest =
    Dict.fromList [ ( "", ( ComponentInvalid, RequestInvalid, noopDecoder ) ) ]


initialModel : Int -> Model
initialModel seedInt =
    let
        ( uuid, seed ) =
            step Uuid.uuidGenerator (initialSeed seedInt)
    in
        { requests = initialRequest
        , seed = seed
        , uuid = Uuid.toString uuid
        }


storeRequest :
    Model
    -> RequestID
    -> Component
    -> Request
    -> ResponseDecoder
    -> RequestStore
storeRequest model request_id component request response =
    Dict.insert request_id ( component, request, response ) model.requests


removeRequest : Model -> RequestID -> RequestStore
removeRequest model request_id =
    Dict.remove request_id model.requests


invalidRequestId : RequestID
invalidRequestId =
    ""


getResponseCode : Int -> ResponseCode
getResponseCode httpCode =
    case httpCode of
        200 ->
            ResponseCodeOk

        404 ->
            ResponseCodeNotFound

        _ ->
            ResponseCodeUnknownError
